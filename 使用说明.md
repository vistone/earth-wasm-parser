# WASM Parser - 完整使用说明

## 项目概述

这是一个使用 **Dart** 和 **Flutter** 直接调用 WebAssembly (WASM) 文件的完整解决方案。项目采用严格的 TypeScript 规范、Vue/Vite 编码规范，并遵循面向对象的设计模式。

## 📁 项目结构

```
wasmParser/
├── lib/
│   ├── main.dart                    # 主应用（完整 UI 版本）
│   ├── main_demo.dart               # 演示应用入口
│   ├── demo_app.dart                # 简化的演示应用
│   ├── wasm_loader.dart             # WASM 加载器核心类
│   ├── earth_plugin_service.dart    # 业务服务封装类
│   └── examples/
│       └── wasm_usage_example.dart  # 使用示例代码集合
├── web/
│   ├── index.html                   # Web 入口页面
│   └── manifest.json                # PWA 配置
├── wasm/
│   ├── earthplugin_web.js           # Emscripten JS 胶水代码
│   └── earthplugin_web.wasm         # 编译后的 WASM 文件
├── pubspec.yaml                     # Dart 项目配置
├── analysis_options.yaml            # Lint 规则配置
├── run.sh                           # 快速启动脚本
├── README.md                        # 项目说明文档
├── ARCHITECTURE.md                  # 架构设计文档
├── QUICKSTART.md                    # 快速入门指南
└── 使用说明.md                      # 本文档
```

## 🚀 快速开始

### 方法一：使用启动脚本（推荐）

```bash
cd /home/stone/wasmParser
./run.sh
```

### 方法二：使用 Flutter 命令

```bash
# 运行完整版应用
flutter run -d chrome

# 运行演示版应用
flutter run -t lib/main_demo.dart -d chrome

# 构建生产版本
flutter build web --release
```

### 方法三：手动步骤

```bash
# 1. 安装依赖
flutter pub get

# 2. 运行应用
flutter run -d chrome

# 3. 或者构建后使用本地服务器
flutter build web
cd build/web
python3 -m http.server 8080
# 访问 http://localhost:8080
```

## 📚 核心类说明

### 1. WasmLoader（核心加载器）

**位置**: `lib/wasm_loader.dart`

**职责**: 
- 加载 WASM 模块和 JavaScript 胶水代码
- 提供底层函数调用接口
- 管理内存分配和释放
- 封装 Emscripten API

**主要方法**:

```dart
class WasmLoader {
  // 加载 WASM 模块
  Future<void> loadModule() async;
  
  // 调用导出的函数
  dynamic callFunction(String functionName, List<dynamic> args);
  
  // 使用 ccall 调用 C 函数
  dynamic ccall(String functionName, String returnType, 
                List<String> argTypes, List<dynamic> args);
  
  // 包装 C 函数为 Dart 函数
  Function? cwrap(String functionName, String returnType, 
                  List<String> argTypes);
  
  // 分配内存
  int malloc(int size);
  
  // 释放内存
  void free(int ptr);
  
  // 获取模块信息
  WasmModuleInfo getModuleInfo();
  
  // 检查是否已加载
  bool get isLoaded;
}
```

**使用示例**:

```dart
final loader = WasmLoader();
await loader.loadModule();

// 调用函数
final result = loader.callFunction('my_function', [arg1, arg2]);

// 使用 ccall
final result = loader.ccall('add', 'number', ['number', 'number'], [10, 20]);

// 使用 cwrap（适合频繁调用）
final addFunc = loader.cwrap('add', 'number', ['number', 'number']);
final result1 = addFunc([5, 10]);
final result2 = addFunc([20, 30]);
```

### 2. EarthPluginService（业务服务层）

**位置**: `lib/earth_plugin_service.dart`

**职责**:
- 封装具体的业务逻辑
- 提供高层次的 API
- 处理数据转换
- 统一错误处理

**主要方法**:

```dart
class EarthPluginService {
  // 初始化服务
  Future<bool> initialize();
  
  // 坐标转换
  CoordinateResult? convertCoordinate(double latitude, double longitude);
  
  // 字符串处理
  String? processString(String input);
  
  // 批量处理数据
  List<double>? batchProcess(List<double> data);
  
  // 获取版本信息
  PluginVersion? getVersion();
  
  // 获取统计信息
  PluginStats getStats();
  
  // 清理资源
  void dispose();
  
  // 检查服务状态
  bool get isReady;
}
```

**使用示例**:

```dart
final loader = WasmLoader();
final service = EarthPluginService(loader);

// 初始化
await service.initialize();

// 使用业务方法
final coord = service.convertCoordinate(39.9042, 116.4074);
print('坐标结果: $coord');

// 获取统计信息
final stats = service.getStats();
print('统计信息: $stats');

// 清理
service.dispose();
```

### 3. UI 组件

**主应用**: `lib/main.dart`
- 完整的 Material Design UI
- 实时状态显示
- 输入/输出区域
- 多功能按钮

**演示应用**: `lib/demo_app.dart`
- 简化的演示界面
- 日志显示
- 功能测试按钮

## 🔧 调用 WASM 函数的三种方式

### 方式一：直接调用（callFunction）

适用于简单的函数调用：

```dart
final result = loader.callFunction('function_name', [arg1, arg2]);
```

**优点**: 简单直接
**缺点**: 每次调用都需要查找函数

### 方式二：使用 ccall

适用于需要明确类型的调用：

```dart
final result = loader.ccall(
  'function_name',
  'number',              // 返回类型: 'number', 'string', 'array', null
  ['number', 'string'],  // 参数类型
  [42, 'hello']         // 参数值
);
```

**优点**: 类型安全，支持字符串
**缺点**: 语法稍复杂

### 方式三：使用 cwrap（推荐用于频繁调用）

适用于需要多次调用同一函数：

```dart
// 一次包装
final func = loader.cwrap('function_name', 'number', ['number', 'number']);

// 多次调用
for (int i = 0; i < 1000; i++) {
  final result = func([i, i * 2]);
}
```

**优点**: 性能最好，避免重复查找
**缺点**: 需要预先包装

## 🎯 实际使用场景

### 场景一：坐标转换

```dart
class CoordinateConverter {
  final WasmLoader _loader;
  Function? _convertFunc;
  
  CoordinateConverter(this._loader);
  
  Future<void> initialize() async {
    await _loader.loadModule();
    // 包装转换函数（性能优化）
    _convertFunc = _loader.cwrap(
      'convert_coordinate',
      'number',
      ['number', 'number']
    );
  }
  
  Point convert(double lat, double lon) {
    final result = _convertFunc!([lat, lon]);
    return Point(result['x'], result['y']);
  }
}
```

### 场景二：图像处理

```dart
class ImageProcessor {
  final WasmLoader _loader;
  
  ImageProcessor(this._loader);
  
  Future<List<int>> processImage(List<int> imageData) async {
    // 分配内存
    final size = imageData.length;
    final ptr = _loader.malloc(size);
    
    try {
      // 复制数据到 WASM 内存
      // (需要使用 Module.HEAP8 等操作)
      
      // 调用处理函数
      final resultPtr = _loader.callFunction('process_image', [ptr, size]);
      
      // 读取结果
      // (从 WASM 内存读取)
      
      return []; // 返回处理后的数据
    } finally {
      // 释放内存
      _loader.free(ptr);
    }
  }
}
```

### 场景三：文本分析

```dart
class TextAnalyzer {
  final EarthPluginService _service;
  
  TextAnalyzer(this._service);
  
  Future<AnalysisResult> analyze(String text) async {
    if (!_service.isReady) {
      await _service.initialize();
    }
    
    try {
      final result = _service.processString(text);
      return AnalysisResult.fromJson(result);
    } catch (e) {
      print('分析失败: $e');
      return AnalysisResult.empty();
    }
  }
}
```

## ⚡ 性能优化建议

### 1. 使用 cwrap 减少函数查找

```dart
// ❌ 低效
for (int i = 0; i < 10000; i++) {
  loader.callFunction('process', [i]);
}

// ✅ 高效
final processFunc = loader.cwrap('process', 'number', ['number']);
for (int i = 0; i < 10000; i++) {
  processFunc([i]);
}
```

### 2. 重用内存缓冲区

```dart
// ❌ 低效
for (int i = 0; i < 1000; i++) {
  final ptr = loader.malloc(1024);
  // 使用...
  loader.free(ptr);
}

// ✅ 高效
final ptr = loader.malloc(1024);
for (int i = 0; i < 1000; i++) {
  // 重用 ptr...
}
loader.free(ptr);
```

### 3. 批量处理数据

```dart
// ❌ 低效：单个处理
final results = items.map((item) => process(item)).toList();

// ✅ 高效：批量处理
final results = batchProcess(items);
```

## 🛠️ 调试技巧

### 1. 查看模块信息

```dart
final info = loader.getModuleInfo();
print('导出函数: ${info.exportedFunctions}');
print('内存大小: ${info.memorySize}');
print('模块类型: ${info.moduleType}');
```

### 2. 使用浏览器开发者工具

- **Console**: 查看 JavaScript 错误和日志
- **Network**: 检查 WASM 文件是否正确加载
- **Performance**: 分析性能瓶颈
- **Memory**: 检查内存泄漏

### 3. 添加日志记录

```dart
class LoggingWasmLoader extends WasmLoader {
  @override
  dynamic callFunction(String name, List args) {
    print('调用函数: $name, 参数: $args');
    final result = super.callFunction(name, args);
    print('返回结果: $result');
    return result;
  }
}
```

## ❗ 常见问题和解决方案

### 问题 1: 模块加载失败

**现象**: "模块未加载" 错误

**原因**: 
- WASM 文件路径不正确
- 使用 file:// 协议而非 HTTP
- CORS 跨域问题

**解决方案**:
```bash
# 使用 HTTP 服务器
cd build/web
python3 -m http.server 8080
```

### 问题 2: 函数调用失败

**现象**: "函数不存在" 错误

**原因**:
- 函数名错误（可能需要 `_` 前缀）
- 函数未被导出
- 模块未完全初始化

**解决方案**:
```dart
// 检查导出的函数
final info = loader.getModuleInfo();
print('可用函数: ${info.exportedFunctions}');

// 尝试添加下划线前缀
loader.callFunction('_function_name', []);
```

### 问题 3: 内存泄漏

**现象**: 应用运行一段时间后变慢

**原因**: 未释放 malloc 分配的内存

**解决方案**:
```dart
// 使用 try-finally 确保释放
final ptr = loader.malloc(1024);
try {
  // 使用内存...
} finally {
  loader.free(ptr);
}
```

### 问题 4: 参数类型错误

**现象**: 调用返回异常结果

**原因**: 参数类型不匹配

**解决方案**:
```dart
// 使用 ccall 明确指定类型
loader.ccall(
  'function',
  'number',              // 明确返回类型
  ['number', 'string'],  // 明确参数类型
  [42, 'text']
);
```

## 📖 学习路径

1. **入门**: 阅读 [QUICKSTART.md](QUICKSTART.md)
2. **示例**: 运行 `lib/main_demo.dart` 查看演示
3. **深入**: 阅读 `lib/examples/wasm_usage_example.dart` 中的示例
4. **架构**: 学习 [ARCHITECTURE.md](ARCHITECTURE.md) 理解设计
5. **实践**: 根据实际需求修改 `earth_plugin_service.dart`

## 🔄 开发工作流

1. **编写 WASM 代码**（C/C++/Rust 等）
2. **使用 Emscripten 编译**:
   ```bash
   emcc your_code.c -o output.js -s EXPORTED_FUNCTIONS='["_your_function"]'
   ```
3. **将生成的 `.js` 和 `.wasm` 放入 `wasm/` 目录**
4. **在 `EarthPluginService` 中添加对应的 Dart 方法**
5. **在 UI 中调用新方法**
6. **测试和调试**

## 📝 代码规范

本项目严格遵循以下规范：

### 1. 命名规范
- **类名**: PascalCase（如 `WasmLoader`）
- **方法名**: camelCase（如 `loadModule`）
- **私有成员**: 下划线前缀（如 `_module`）
- **常量**: lowerCamelCase（如 `maxAttempts`）

### 2. 文档注释
```dart
/// 加载 WASM 模块
/// 
/// 这个方法会动态加载 Emscripten 生成的 JS 文件
/// 并等待 WASM 模块初始化完成
/// 
/// 抛出 [Exception] 如果加载失败
Future<void> loadModule() async {
  // 实现...
}
```

### 3. 错误处理
```dart
try {
  // 操作
} catch (e) {
  print('操作失败: $e');
  rethrow; // 或返回默认值
}
```

### 4. 面向对象设计
- 使用类封装功能
- 遵循单一职责原则
- 使用依赖注入
- 提供清晰的接口

## 🎓 进阶主题

### 1. 自定义数据类型

```dart
class CustomData {
  final int id;
  final String name;
  
  CustomData(this.id, this.name);
  
  // 序列化为 WASM 可接受的格式
  List<dynamic> toWasmArgs() => [id, name];
  
  // 从 WASM 结果反序列化
  factory CustomData.fromWasmResult(dynamic result) {
    return CustomData(
      result['id'] as int,
      result['name'] as String,
    );
  }
}
```

### 2. 异步流处理

```dart
Stream<Result> processStream(Stream<Input> inputs) async* {
  await loader.loadModule();
  
  await for (final input in inputs) {
    final result = loader.callFunction('process', [input]);
    yield Result(result);
  }
}
```

### 3. 状态管理集成

```dart
// 使用 Provider
class WasmProvider extends ChangeNotifier {
  final WasmLoader _loader = WasmLoader();
  bool _isLoaded = false;
  
  bool get isLoaded => _isLoaded;
  
  Future<void> load() async {
    await _loader.loadModule();
    _isLoaded = true;
    notifyListeners();
  }
}

// 在 Widget 中使用
Consumer<WasmProvider>(
  builder: (context, provider, child) {
    return Text(provider.isLoaded ? '已加载' : '未加载');
  },
)
```

## 📞 获取帮助

如果您遇到问题：

1. 查看 [QUICKSTART.md](QUICKSTART.md) 快速入门指南
2. 阅读 [ARCHITECTURE.md](ARCHITECTURE.md) 架构文档
3. 运行示例代码 `lib/examples/wasm_usage_example.dart`
4. 检查浏览器控制台的错误信息
5. 查看本文档的"常见问题"部分

## 🎉 总结

这个项目提供了一个**完整的、生产就绪的**解决方案，用于在 Dart/Flutter 中调用 WebAssembly 模块。主要特点：

- ✅ **面向对象设计**：清晰的类层次和职责分离
- ✅ **类型安全**：利用 Dart 的强类型系统
- ✅ **性能优化**：支持 cwrap 和内存重用
- ✅ **错误处理**：完善的异常处理机制
- ✅ **易于扩展**：模块化设计，易于添加新功能
- ✅ **完整文档**：详细的注释和文档

祝您使用愉快！🚀

